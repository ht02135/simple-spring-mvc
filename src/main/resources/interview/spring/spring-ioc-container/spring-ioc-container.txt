
spring-ioc-container
spring-ioc-container.txt

Spring IoC Interview Questions

/////////////////

1>What are IoC and DI in Spring? and java and xml example

    In Spring, IoC (Inversion of Control) and DI (Dependency Injection) are 
    fundamental concepts that help build loosely coupled and modular applications. 
    IoC is the principle, and DI is a specific design pattern that implements 
    that principle.

	Inversion of Control (IoC)
	IoC is a design principle where the framework, rather than the application code, 
	takes control of object creation, configuration, and lifecycle management. 
	Traditionally, you'd create objects within your code using the new keyword. 
	With IoC, the Spring container "inverts" this control, handling the instantiation 
	and wiring of objects (beans) for you.  This means your code focuses on 
	its business logic, delegating the object management responsibilities to 
	the framework.  
	hung: ioc is spring framework manage pojo obj lifecycle.

    Dependency Injection (DI)
	DI is the most common implementation of IoC in Spring. It's a design pattern 
	where an object receives its dependencies (other objects it needs to function) 
	from an external source, rather than creating them itself. Instead of a class 
	looking up or creating its dependencies, the Spring container "injects" them 
	into the class. The dependencies are typically provided through a constructor, 
	setter method, or field.
	hung: di is pojo obj receive its dependencies from externaal source.

    1>Constructor Injection: Dependencies are provided through the class's constructor. 
    This is the preferred method as it ensures the object is created with all 
    its necessary dependencies and makes the object immutable.
	2>Setter Injection: Dependencies are provided through setter methods. This is 
	useful for optional dependencies or for classes that need to be reconfigured 
	at runtime.
	3>Field Injection: Dependencies are injected directly into a field using 
	annotations. While convenient, it's generally discouraged in favor of 
	constructor injection because it hides dependencies and makes the class harder to test.

    In this code, the NotificationService doesn't create a MessageService instance 
    itself. Instead, it declares its dependency in the constructor. Spring's 
    @Autowired annotation tells the container to find a bean that implements 
    the MessageService interface (in this case, EmailService) and inject it.
    
    1><beans>: This is the root element of the Spring configuration file. It 
    contains the definitions for all your beans.
	2><bean>: This element defines a single bean. The id attribute is the 
	unique name of the bean, and the class attribute specifies the fully 
	qualified class name.
	3><constructor-arg>: This element is used to inject a dependency into a 
	bean's constructor. The ref attribute points to the ID of another bean 
	(emailService in this case) that will be passed into the constructor of 
	the notificationService bean. This is how Dependency Injection is 
	configured in XML.
	4><property>: An alternative to <constructor-arg>, this element is used 
	for setter injection. You would use it like <property name="messageService" 
	ref="emailService"/> if NotificationService had a setMessageService method.

----------------

	I cannot provide a single applicationContext.xml example that demonstrates all 
	five types of injection, as field injection is an annotation-based approach 
	and isn't configured directly in the XML file. Instead, the XML configuration 
	enables the scanning of Java classes where field injection is used.

	Here is an example that demonstrates the other four types of injection directly 
	within the applicationContext.xml file, along with the necessary configuration 
	to support annotation-based field injection in your Java code.

	Key Takeaways
    1>Constructor Injection: The <constructor-arg> tag specifies the values or 
    references to be passed to a bean's constructor. This is useful for mandatory 
    dependencies.

    2>Setter Injection: The <property> tag with a name attribute matching a 
    setter method is used to inject dependencies or values. It’s useful for 
    optional dependencies.
    hung : i think setter injection is for bean compatible thing..

    3>ref Injection: This is a type of setter or constructor injection where 
    the <property> or <constructor-arg> tag uses the ref attribute to point 
    to another bean's ID, linking the two.

    4>value Injection: Similar to ref but uses the value attribute to inject 
    literal values (e.g., strings, numbers) instead of other beans.

    5>Field Injection: This method is not configured directly in XML. Instead, 
    you use <context:component-scan> to tell Spring to look for annotations 
    (@Autowired, @Resource, etc.) in your Java code. Spring then automatically 
    injects the dependencies into the annotated fields, making the XML 
    configuration cleaner.
    
    hung: now i see why field injection should be avoid, because CANT DO IT for xml
    
/////////////////

2>What is the use of IoC containers?

What is the use of IoC containers?
1>IoC containers are frameworks that manage object creation, configuration, 
and lifecycle in applications. Their primary uses include:

2>Dependency Management: IoC containers automatically create and inject 
dependencies into objects, eliminating the need for manual object 
instantiation. Instead of objects creating their own dependencies, 
the container provides them.

3>Loose Coupling: By managing dependencies externally, IoC containers 
reduce tight coupling between classes. Objects depend on abstractions 
(interfaces) rather than concrete implementations, making code more 
flexible and maintainable.

4>Configuration Centralization: All dependency configurations are 
managed in one place (XML files, annotations, or configuration classes), 
making it easier to modify application behavior without changing source 
code.

5>Lifecycle Management: Containers handle object creation, initialization, 
and destruction, including managing singleton patterns, prototype instances, 
and cleanup operations.

6>Testing Enhancement: IoC containers make unit testing easier by allowing 
easy substitution of mock objects or test implementations for real 
dependencies.

/////////////////

3>What is autowiring, and name the different modes of it?

What is autowiring, and what are the different modes?
Autowiring is a feature that automatically injects dependencies into 
objects without explicit configuration. The container automatically 
identifies and injects the required dependencies based on various 
strategies.

The different autowiring modes are:
1>No Autowiring (default): Dependencies must be explicitly defined 
through configuration. No automatic injection occurs.

	<bean id="serviceA" class="com.example.ServiceA" />
	<bean id="clientA" class="com.example.ClientA">
		<property name="serviceA" ref="serviceA" />
	</bean>
	
2>By Name: The container matches property names with bean names in 
the configuration. If a property named "userService" exists, it looks 
for a bean with the same name.

	<bean id="serviceB" class="com.example.ServiceB" />
	<bean id="clientB" class="com.example.ClientB" autowire="byName" />
	
3>By Type: The container injects dependencies based on the property's 
data type. It searches for beans that match the required type and 
injects them automatically.

	<bean id="someServiceC" class="com.example.ServiceC" />
	<bean id="clientC" class="com.example.ClientC" autowire="byType" />
	
4>By Constructor: Dependencies are injected through constructor 
parameters. The container uses reflection to determine constructor
 parameter types and injects matching beans.
 
	<bean id="serviceD" class="com.example.ServiceD" />
	<bean id="clientD" class="com.example.ClientD"
		autowire="constructor" />
		
5>Autodetect: The container first attempts constructor autowiring. 
If no suitable constructor is found, it falls back to autowiring 
by type for properties.

The autodetect option is deprecated.  so eclipse will alert as error

	<bean id="serviceE" class="com.example.ServiceE" />
	<bean id="clientE" class="com.example.ClientE"
		autowire="autodetect" />
		
These autowiring modes provide different levels of automation and 
flexibility, allowing developers to choose the approach that best 
fits their application's architecture and requirements.

/////////////////

4>What is DispatcherServlet in Spring MVC? In other words, can you 
explain the Spring MVC architecture?

The DispatcherServlet is the front controller in a Spring MVC web application. 
It's the central point of entry for all incoming HTTP requests. Its primary 
role is to manage and orchestrate the entire request-handling process by 
delegating tasks to other components within the Spring framework.  
This single-servlet design is a key feature of the Spring MVC framework, 
as it consolidates the request flow, making the application more manageable 
and extensible.

The Spring MVC Architecture and Request Flow

The Spring MVC framework follows the Model-View-Controller (MVC) design 
pattern, separating the application's concerns into three distinct layers:

1>Model: Represents the application's data and business logic. It's 
responsible for managing and manipulating data.

2>View: Handles the presentation layer, rendering the data from the 
Model into a format the user can understand, such as HTML.

3>Controller: Acts as the intermediary, receiving user requests, 
processing them by interacting with the Model, and then selecting 
the appropriate View to display the result.

-------------------

The request flow in a Spring MVC application is a well-defined 
sequence of steps orchestrated by the DispatcherServlet:

1>Incoming Request: A user sends an HTTP request to the web application.

2>DispatcherServlet intercepts: The DispatcherServlet, configured as 
the front controller, receives the request.

	<servlet>
		<servlet-name>mvc</servlet-name>
		<servlet-class>
			org.springframework.web.servlet.DispatcherServlet
		</servlet-class>
		<load-on-startup>1</load-on-startup>
	</servlet>

3>Handler Mapping: The DispatcherServlet consults a HandlerMapping to 
determine which controller is responsible for handling the specific 
request, based on its URL and other parameters.

	<servlet-mapping>
		<servlet-name>mvc</servlet-name>
		<url-pattern>/mvc/*</url-pattern>
	</servlet-mapping>

4>Controller Execution: The DispatcherServlet sends the request to the 
identified Controller. The controller processes the request, performs 
any necessary business logic (often by interacting with a service or 
data access layer), and prepares data to be displayed.

5>Model and View: The controller returns a ModelAndView object, which 
contains the data (Model) to be displayed and the logical name of the 
View to be rendered.

6>View Resolution: The DispatcherServlet uses a ViewResolver to map the 
logical view name to an actual view component, such as a JSP file or 
a Thymeleaf template.

7>Rendering the View: The DispatcherServlet passes the model data to 
the resolved view. The view then renders the final output (e.g., an 
HTML page) with the provided data.

8>Final Response: The DispatcherServlet sends the rendered response 
back to the client's browser.

This architecture ensures a clear separation of concerns, making the 
application easier to develop, maintain, and scale.

/////////////////

5>Which method is used for shutting down IoC containers in Spring?

The close() method is used for shutting down an IoC container in Spring.

Specifically, for an ApplicationContext (which is the more common 
type of Spring container in modern applications), the close() method 
is used to destroy all the beans in the container, releasing any 
resources they might hold. The ConfigurableApplicationContext 
interface provides this close() method, and most concrete 
ApplicationContext implementations (like ClassPathXmlApplicationContext 
or AnnotationConfigApplicationContext) inherit it.

While a web application's container is typically managed automatically 
when the application is shut down, in standalone applications, it's a 
good practice to explicitly call the close() method to ensure a clean 
shutdown.

    public static void main(String[] args) {
        // Load context
        ConfigurableApplicationContext context =
                new ClassPathXmlApplicationContext("applicationContext.xml");

        // Get bean
        ResourceBean bean = context.getBean("resourceBean", ResourceBean.class);
        bean.doWork();

        // Explicit shutdown (important for standalone apps)
        context.close();
    }
    
    <!-- Demo bean with init and destroy methods -->
    <bean id="resourceBean" class="com.example.ResourceBean"
          init-method="init"
          destroy-method="cleanup"/>

/////////////////

6>What is the implementation of List that is used when you use the <list> tag in a bean definition?

When you use the <list> tag in a Spring bean definition, the implementation of java.util.List that Spring uses by default is java.util.ArrayList.

When the Spring container parses the XML configuration and encounters a <list> element within a <bean> definition, it creates an instance of ArrayList to hold the specified elements. The elements defined within the <list> tag are then added to this ArrayList instance.

For example, a bean definition like this:
<bean id="myBean" class="com.example.MyClass">
    <property name="myList">
        <list>
            <value>item1</value>
            <value>item2</value>
        </list>
    </property>
</bean>

When you use the <list> tag in a Spring bean definition, the implementation of java.util.List that Spring uses by default is java.util.ArrayList.

How it Works

When the Spring container parses the XML configuration and encounters a <list> element within a <bean> definition, it creates an instance of ArrayList to hold the specified elements. The elements defined within the <list> tag are then added to this ArrayList instance.

For example, a bean definition like this:
XML

<bean id="myBean" class="com.example.MyClass">
    <property name="myList">
        <list>
            <value>item1</value>
            <value>item2</value>
        </list>
    </property>
</bean>

...results in Spring creating an ArrayList containing the string values "item1" and "item2" and injecting it into the myList property of the myBean instance.

This default choice of ArrayList is suitable for most use cases due to its efficient random access and common usage patterns. While you cannot specify a different List implementation directly with the <list> tag, you can achieve this by using a factory method or a custom FactoryBean if a different type, such as LinkedList, is required.

----------------------

	This shows list of Employee objects, set of department names, and map of 
	project codes to names injected via XML  
	
    <!-- Company Bean -->
    <bean id="company" class="com.example.Company">
        <!-- Injecting List -->
        <property name="employees">
            <list>
                <bean class="com.example.Employee">
                    <property name="id" value="101"/>
                    <property name="name" value="Alice"/>
                </bean>
                <bean class="com.example.Employee">
                    <property name="id" value="102"/>
                    <property name="name" value="Bob"/>
                </bean>
            </list>
        </property>

        <!-- Injecting Set -->
        <property name="departments">
            <set>
                <value>HR</value>
                <value>Finance</value>
                <value>IT</value>
            </set>
        </property>

        <!-- Injecting Map -->
        <property name="projects">
            <map>
                <entry key="P001" value="Banking System"/>
                <entry key="P002" value="E-Commerce Platform"/>
                <entry key="P003" value="AI Chatbot"/>
            </map>
        </property>
    </bean>
    
/////////////////

7>How do you use a particular implementation of collection in your 
bean definition?

You can use a particular implementation of a collection in a Spring 
bean definition by either using a specific collection-type XML tag 
or by leveraging constructor injection with the fully qualified class name.

Using XML Configuration

For XML-based configuration, you can declare a specific implementation 
of a collection by using a <property> or <constructor-arg> tag and then 
nesting the specific implementation tag within it.

Example with <list>

The <list> tag, by default, creates an ArrayList. You can specify a 
different implementation, like a LinkedList, by using the ref 
attribute and the fully qualified class name.

    <!-- ====== PROPERTY INJECTION ====== -->
    <bean id="companyProperty" class="com.example.Company">
        <property name="employees">
            <list>
                <bean class="com.example.Employee">
                    <property name="id" value="101"/>
                    <property name="name" value="Alice"/>
                </bean>
                <bean class="com.example.Employee">
                    <property name="id" value="102"/>
                    <property name="name" value="Bob"/>
                </bean>
            </list>
        </property>

        <property name="departments">
            <set>
                <value>HR</value>
                <value>Finance</value>
                <value>IT</value>
            </set>
        </property>

        <property name="projects">
            <map>
                <entry key="P001" value="Banking System"/>
                <entry key="P002" value="E-Commerce Platform"/>
                <entry key="P003" value="AI Chatbot"/>
            </map>
        </property>
    </bean>


    <!-- ====== CONSTRUCTOR INJECTION ====== -->
    <bean id="companyConstructor" class="com.example.Company">
        <constructor-arg>
            <list>
                <bean class="com.example.Employee">
                    <constructor-arg value="201"/>
                    <constructor-arg value="Charlie"/>
                </bean>
                <bean class="com.example.Employee">
                    <constructor-arg value="202"/>
                    <constructor-arg value="Diana"/>
                </bean>
            </list>
        </constructor-arg>

        <constructor-arg>
            <set>
                <value>Marketing</value>
                <value>Sales</value>
            </set>
        </constructor-arg>

        <constructor-arg>
            <map>
                <entry key="P101" value="Cloud Migration"/>
                <entry key="P102" value="Mobile App"/>
            </map>
        </constructor-arg>
    </bean>

-------------------

To use a different implementation, like a LinkedList, you would need 
to define it as a separate bean and then inject it.

Example with a Specific Bean

A more flexible and explicit way is to define the collection as a 
separate bean and then inject it by reference. This approach is 
useful when you need to use a specific, non-default implementation.

    <!-- ====== SEPARATE COLLECTION BEANS ====== -->

    <!-- Employees list -->
    <bean id="employeeList" class="java.util.LinkedList">
        <constructor-arg>
            <list>
                <bean class="com.example.Employee">
                    <constructor-arg value="301"/>
                    <constructor-arg value="Eve"/>
                </bean>
                <bean class="com.example.Employee">
                    <constructor-arg value="302"/>
                    <constructor-arg value="Frank"/>
                </bean>
            </list>
        </constructor-arg>
    </bean>

    <!-- Departments set -->
    <bean id="departmentSet" class="java.util.HashSet">
        <constructor-arg>
            <set>
                <value>Operations</value>
                <value>Support</value>
            </set>
        </constructor-arg>
    </bean>

    <!-- Projects map -->
    <bean id="projectMap" class="java.util.HashMap">
        <constructor-arg>
            <map>
                <entry key="P201" value="Data Warehouse"/>
                <entry key="P202" value="Cybersecurity"/>
            </map>
        </constructor-arg>
    </bean>

    <!-- Company using collection refs -->
    <bean id="companyRefCollections" class="com.example.Company">
        <property name="employees" ref="employeeList"/>
        <property name="departments" ref="departmentSet"/>
        <property name="projects" ref="projectMap"/>
    </bean>

/////////////////

8>Are singleton beans in Spring a regular singleton object?

No, Spring singleton beans are not regular singleton objects. 

A regular singleton object is a design pattern where a class 
is responsible for ensuring that only one instance of itself 
is created and providing a global access point to that instance. 

Spring singletons, on the other hand, are a specific bean scope 
managed by the Spring container.

Key Differences

1>Instance Management: A regular singleton class manages its own 
lifecycle, often through a private constructor and a static 
factory method.  

A Spring singleton bean has its lifecycle managed entirely by 
the Spring container. The container creates a single instance 
of the bean and then provides it to other beans that depend on it.

2>Scope: In the classic singleton pattern, the single instance 
is globally available within the entire JVM. 

For Spring, the singleton scope means there is only one instance 
per Spring container. If you have multiple Spring containers in 
your application (e.g., in a microservices architecture or with 
parent/child contexts), each container will have its own single 
instance of the bean.

3>Dependency Injection: The classic singleton pattern often makes 
it difficult to inject dependencies because the class is self-managing. 
In contrast, Spring singleton beans are designed to work seamlessly 
with dependency injection. The Spring container manages all dependencies 
and injects them into the singleton bean for you.

4>Thread Safety: The developer is responsible for ensuring the thread 
safety of a regular singleton object, which can be tricky to implement 
correctly. While Spring singleton beans are not inherently thread-safe, 
the container ensures that the bean instance is created in a 
thread-safe manner. Developers must still ensure the bean's state 
and methods are thread-safe if it holds mutable data.

--------------

    <!-- Spring singleton bean -->
    <bean id="springSingleton" 
          class="com.example.SpringSingleton" 
          scope="singleton"/>
          
	Spring Singleton (applicationContext.xml) → lifecycle controlled by 
	the container (ApplicationContext).
	Lifecycle managed entirely by the Spring container.
	One instance per Spring context (not per JVM).
	Works seamlessly with dependency injection.

	in Spring the difference comes down to the scope attribute in your 
	bean definition.
	By default, beans in Spring are scope="singleton". But you can 
	change the scope, most commonly to prototype, to make them non-singleton.
	1. Spring Singleton (scope="singleton")
	One instance per Spring IoC container.
	All requests for that bean ID return the same instance.
	Container creates the instance at startup (eager by default, unless 
	lazy-init="true").

	In Spring:
	Default scope = singleton
	So if you don’t specify scope, the bean is already a singleton.
	Writing scope="singleton" is optional — it’s just being explicit.
	scope="singleton"

/////////////////

9>If an inner bean is defined with an id, can you use this id to fetch 
the bean from the container? and applicationcontext.xml example

    No, you can't use the id of an inner bean to fetch it from the 
    Spring container. Inner beans are a specific type of bean definition 
    used solely within the scope of another bean's property or constructor 
    argument. They don't have a standalone identity in the container, 
    even if you assign them an id. 
    
    The key concept is that an inner bean's lifecycle is completely 
    dependent on the bean that contains it. They're not a top-level 
    bean in the Spring container's registry. The id you assign to an 
    inner bean is primarily for documentation purposes or for potential 
    use within the XML file itself (like for referencing within a list 
    of inner beans), but it doesn't make it a "first-class" bean that 
    can be retrieved directly using methods like ApplicationContext.getBean().
    
    In this example:
    1>The customer bean is a regular, top-level bean. You can fetch 
    it from the container using context.getBean("customer").
    2>The innerPerson bean is an inner bean. Although it has the id 
    innerPerson, a call like context.getBean("innerPerson") will 
    result in a NoSuchBeanDefinitionException because the container 
    doesn't recognize it as a top-level bean.

    <bean id="customer" class="com.example.Customer">
        <property name="person">
            <bean id="innerPerson" class="com.example.Person">
                <property name="name" value="John Doe"/>
            </bean>
        </property>
    </bean>
    
------------------------------

    <!-- Outer bean that contains an inner bean -->
    <bean id="person" class="com.example.Person">
        <property name="name" value="John Doe"/>
        <property name="address">
            <!-- Inner bean with explicit ID -->
            <bean id="homeAddress" class="com.example.Address">
                <property name="street" value="123 Main St"/>
                <property name="city" value="Springfield"/>
                <property name="zipCode" value="12345"/>
            </bean>
        </property>
    </bean>
    
        // Retrieve the outer bean
        Person person = (Person) context.getBean("person");
        
        // Retrieve the inner bean by its ID
        Address homeAddress = (Address) context.getBean("homeAddress");
        
------------------------------

	interesting, chatgpt say no, but claude say yes
	hung : i gonna side with yes, if inner bean has id, then i dont see why you
	cant reference it by id. but is it stupid to do so probably YES
	
/////////////////

10>What are the actuator-provided endpoints used for monitoring the Spring boot application?
    
/////////////////