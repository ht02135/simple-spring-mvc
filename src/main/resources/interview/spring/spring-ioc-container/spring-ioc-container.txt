
spring-ioc-container
spring-ioc-container.txt

Spring IoC Interview Questions

/////////////////

1>What are IoC and DI in Spring? and java and xml example

    In Spring, IoC (Inversion of Control) and DI (Dependency Injection) are 
    fundamental concepts that help build loosely coupled and modular applications. 
    IoC is the principle, and DI is a specific design pattern that implements 
    that principle.

	Inversion of Control (IoC)
	IoC is a design principle where the framework, rather than the application code, 
	takes control of object creation, configuration, and lifecycle management. 
	Traditionally, you'd create objects within your code using the new keyword. 
	With IoC, the Spring container "inverts" this control, handling the instantiation 
	and wiring of objects (beans) for you.  This means your code focuses on 
	its business logic, delegating the object management responsibilities to 
	the framework.  
	hung: ioc is spring framework manage pojo obj lifecycle.

    Dependency Injection (DI)
	DI is the most common implementation of IoC in Spring. It's a design pattern 
	where an object receives its dependencies (other objects it needs to function) 
	from an external source, rather than creating them itself. Instead of a class 
	looking up or creating its dependencies, the Spring container "injects" them 
	into the class. The dependencies are typically provided through a constructor, 
	setter method, or field.
	hung: di is pojo obj receive its dependencies from externaal source.

    1>Constructor Injection: Dependencies are provided through the class's constructor. 
    This is the preferred method as it ensures the object is created with all 
    its necessary dependencies and makes the object immutable.
	2>Setter Injection: Dependencies are provided through setter methods. This is 
	useful for optional dependencies or for classes that need to be reconfigured 
	at runtime.
	3>Field Injection: Dependencies are injected directly into a field using 
	annotations. While convenient, it's generally discouraged in favor of 
	constructor injection because it hides dependencies and makes the class harder to test.

    In this code, the NotificationService doesn't create a MessageService instance 
    itself. Instead, it declares its dependency in the constructor. Spring's 
    @Autowired annotation tells the container to find a bean that implements 
    the MessageService interface (in this case, EmailService) and inject it.
    
    1><beans>: This is the root element of the Spring configuration file. It 
    contains the definitions for all your beans.
	2><bean>: This element defines a single bean. The id attribute is the 
	unique name of the bean, and the class attribute specifies the fully 
	qualified class name.
	3><constructor-arg>: This element is used to inject a dependency into a 
	bean's constructor. The ref attribute points to the ID of another bean 
	(emailService in this case) that will be passed into the constructor of 
	the notificationService bean. This is how Dependency Injection is 
	configured in XML.
	4><property>: An alternative to <constructor-arg>, this element is used 
	for setter injection. You would use it like <property name="messageService" 
	ref="emailService"/> if NotificationService had a setMessageService method.

----------------

	I cannot provide a single applicationContext.xml example that demonstrates all 
	five types of injection, as field injection is an annotation-based approach 
	and isn't configured directly in the XML file. Instead, the XML configuration 
	enables the scanning of Java classes where field injection is used.

	Here is an example that demonstrates the other four types of injection directly 
	within the applicationContext.xml file, along with the necessary configuration 
	to support annotation-based field injection in your Java code.

	Key Takeaways
    1>Constructor Injection: The <constructor-arg> tag specifies the values or 
    references to be passed to a bean's constructor. This is useful for mandatory 
    dependencies.

    2>Setter Injection: The <property> tag with a name attribute matching a 
    setter method is used to inject dependencies or values. Itâ€™s useful for 
    optional dependencies.
    hung : i think setter injection is for bean compatible thing..

    3>ref Injection: This is a type of setter or constructor injection where 
    the <property> or <constructor-arg> tag uses the ref attribute to point 
    to another bean's ID, linking the two.

    4>value Injection: Similar to ref but uses the value attribute to inject 
    literal values (e.g., strings, numbers) instead of other beans.

    5>Field Injection: This method is not configured directly in XML. Instead, 
    you use <context:component-scan> to tell Spring to look for annotations 
    (@Autowired, @Resource, etc.) in your Java code. Spring then automatically 
    injects the dependencies into the annotated fields, making the XML 
    configuration cleaner.
    
    hung: now i see why field injection should be avoid, because CANT DO IT for xml
    
/////////////////

2>What is the use of IoC containers?
3>What is autowiring, and name the different modes of it?
4>What is DispatcherServlet in Spring MVC? In other words, can you explain the Spring MVC architecture?
5>Which method is used for shutting down IoC containers in Spring?
6>What is the implementation of List that is used when you use the <list> tag in a bean definition?
7>How do you use a particular implementation of collection in your bean definition?
8>Are singleton beans in Spring a regular singleton object?
9>If an inner bean is defined with an id, can you use this id to fetch the bean from the container?
10>What are the actuator-provided endpoints used for monitoring the Spring boot application?
    
/////////////////