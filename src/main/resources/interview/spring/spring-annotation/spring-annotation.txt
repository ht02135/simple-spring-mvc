
spring-annotation
spring-annotation.txt

Spring Annotations Interview Questions

/////////////////

1>How can annotation wiring be turned on in Spring?

To enable annotation wiring in Spring, you need to configure your Spring application context to scan for components and process annotations.

Annotation-Based Configuration
There are a few ways to turn on annotation wiring, depending on whether you're using XML, Java-based configuration, or a combination of both.

---------------
1. Java-based Configuration

This is the modern and preferred approach.

@Configuration and @ComponentScan: The key is to use the @Configuration 
annotation on a class to declare it as a Spring configuration class and 
@ComponentScan to tell Spring where to look for components (beans) 
annotated with @Component, @Service, @Repository, and @Controller.
    
@Configuration
@ComponentScan(basePackages = "com.example.yourpackage")
public class AppConfig {
    // You can define other beans here if needed
}

The basePackages attribute specifies the package(s) to scan. Spring will 
automatically find classes like this one:

@Service
public class MyService {
    // Spring will inject a MyRepository bean here
    @Autowired
    private MyRepository myRepository;
}

@Repository
public class MyRepository {
    // ...
}

-----------------------

2. XML-based Configuration

If you're using XML, you can enable annotation processing with the 
<context:component-scan> element.

<context:component-scan>: Add this element to your XML application context file, 
specifying the base package to scan.
    
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="
           http://www.springframework.org/schema/beans 
           https://www.springframework.org/schema/beans/spring-beans.xsd
           http://www.springframework.org/schema/context 
           https://www.springframework.org/schema/context/spring-context.xsd">

    <context:component-scan base-package="com.example.yourpackage"/>

</beans>

The base-package attribute works just like the basePackages in the Java 
configuration, telling Spring where to search for annotated components.

ðŸ’¡ Note: In older versions of Spring (prior to 2.5), you might have had 
to explicitly declare <context:annotation-config/> to enable annotations 
like @Autowired. The <context:component-scan/> element now implicitly 
includes the functionality of <context:annotation-config/>, so you generally 
don't need both.

Common Annotations for Wiring

Once annotation wiring is enabled, Spring processes these key annotations 
to manage dependencies:

    @Autowired: This is the most common annotation for injecting dependencies. 
    Spring automatically finds a matching bean and injects it. It can be 
    used on constructors, setters, or fields.

    @Qualifier: Used with @Autowired to specify a particular bean when there 
    are multiple beans of the same type.

    @Component: A generic stereotype for any Spring-managed component.

    @Service: A specialization of @Component for the service layer.

    @Repository: A specialization of @Component for the data access layer.

    @Controller: A specialization of @Component for the web layer.

By using one of the configuration methods above, you give Spring the green 
light to scan, find, and wire these annotated components together, 
automatically managing the dependencies in your application.

/////////////////

2>Explain @Required annotation?

The @Required annotation is a Spring annotation used to indicate that 
a bean property must be populated at configuration time. If the 
annotated setter method is not called by the container, a 
BeanInitializationException will be thrown.

This annotation is typically applied to a setter method of a bean.

Key Points about @Required

1>Purpose: It acts as a constraint, forcing you to provide a value 
for a property, either through XML configuration or Java-based 
configuration. This ensures that the bean is in a valid state after 
it's initialized.

2>Usage: The annotation is placed on the setter method of a bean's property.
    
import org.springframework.beans.factory.annotation.Required;

public class MyBean {

    private String requiredProperty;

    @Required
    public void setRequiredProperty(String requiredProperty) {
        this.requiredProperty = requiredProperty;
    }

    // Other methods and properties
}

1>Mechanism: For @Required to work, you must enable a BeanPostProcessor 
in your Spring configuration. This is automatically handled when you 
use the <context:annotation-config/> element in XML or @ComponentScan 
in Java configuration. The RequiredAnnotationBeanPostProcessor is 
responsible for checking if all properties with the @Required annotation 
have been set.

2>Deprecation: The @Required annotation has been deprecated since 
Spring 5.1. The Spring team recommends using constructor injection 
for mandatory dependencies instead. Constructor injection achieves 
the same goal by forcing you to provide all required dependencies when 
the bean is created, making the requirement explicit and immutable.

Why Constructor Injection is Recommended

Constructor injection is considered a best practice for a number of reasons:

1>Immutability: Once a bean is created, its required properties cannot be 
changed, leading to safer and more predictable code.

2>Explicit Contracts: It makes the dependencies of a class explicit and 
clear from its constructor signature.

3>Easier Testing: It makes unit testing simpler because you can easily 
instantiate the object with mock dependencies without needing a Spring container.

public class MyService {
    private final MyDependency myDependency;

    // The dependency is required to construct the bean
    public MyService(MyDependency myDependency) {
        this.myDependency = myDependency;
    }
}

------------------

    4. âœ… Answering Directly:
	1>Do we need @ComponentScan (Java config)?
	Yes, if you want to detect @Component, @Service, etc.
	Not needed if you define beans only via @Bean methods.

	2>Do we need <context:component-scan/> (XML)?
	Yes, same reason â€” for detecting annotated beans.
	Not needed if you define beans only via <bean> tags.

	3>Do we need <context:annotation-config/>?
	Yes in XML config â†’ it registers RequiredAnnotationBeanPostProcessor, 
	AutowiredAnnotationBeanPostProcessor, etc.
	No in Java config â†’ AnnotationConfigApplicationContext automatically registers these.

	4>Do we need RequiredAnnotationBeanPostProcessor explicitly?
	No â†’ itâ€™s included when you use <context:annotation-config/> or @ComponentScan.
	Only declare explicitly if you donâ€™t want the other processors but still want 
	@Required checked. 
	
------------------

	hung : translate into what a pain in ass, just do following
	1>xml
	<context:annotation-config/>
	<context:component-scan base-package="com.example"/>
	2>config java
	@Configuration
	@ComponentScan(basePackages = "com.example") // enable scanning
	public class AppConfig

/////////////////

3>What does @RequestMapping annotation mean?

The @RequestMapping annotation in Spring MVC is used to map web requests 
to specific handler methods in a controller class. It essentially tells 
Spring which method should handle a particular HTTP request based on 
its URL, and other parameters like the HTTP method (GET, POST, etc.), 
headers, and request parameters.

You can apply @RequestMapping at both the class level and the method level.

1>Class-Level Mapping: When you apply @RequestMapping to a class, it specifies 
a base URL for all the handler methods within that controller. For example, 
@RequestMapping("/users") means all methods inside this controller will handle 
requests that start with /users.

2>Method-Level Mapping: When applied to a method, it further refines the 
mapping. If a controller has @RequestMapping("/users"), a method with 
@RequestMapping("/profile") will handle requests to /users/profile.

Key Attributes

@RequestMapping has several attributes to define the mapping more precisely:

1>value or path: Specifies the URL or URL pattern to which the method is mapped.
2>method: Specifies the HTTP request method(s) (e.g., RequestMethod.GET, RequestMethod.POST).
3>consumes: Specifies the media types the controller can consume (e.g., application/json).
4>produces: Specifies the media types the controller can produce (e.g., application/xml).


Simplified Annotations

While @RequestMapping is versatile, Spring introduced more specific and 
easier-to-read annotations that are shortcuts for common use cases. 
These are highly recommended for clarity and are themselves annotated 
with @RequestMapping.

1>@GetMapping: A shortcut for @RequestMapping(method = RequestMethod.GET).
2>@PostMapping: A shortcut for @RequestMapping(method = RequestMethod.POST).
3>@PutMapping: A shortcut for @RequestMapping(method = RequestMethod.PUT).
4>@DeleteMapping: A shortcut for @RequestMapping(method = RequestMethod.DELETE).
5>@PatchMapping: A shortcut for @RequestMapping(method = RequestMethod.PATCH).

-----------------

    // GET
    @GetMapping(value = "/hello", produces = {MediaType.APPLICATION_JSON_VALUE, MediaType.APPLICATION_XML_VALUE})
    public ApiResponse<User> sayHello(@RequestParam(defaultValue = "Guest") String name) {
        User user = new User();
        user.setName(name);
        user.setAge(0);

        return new ApiResponse<>("SUCCESS", "Hello " + name, user);
    }

    // POST
    @PostMapping(value = "/create",
                 consumes = {MediaType.APPLICATION_JSON_VALUE, MediaType.APPLICATION_XML_VALUE},
                 produces = {MediaType.APPLICATION_JSON_VALUE, MediaType.APPLICATION_XML_VALUE})
    public ApiResponse<User> createUser(@RequestBody ApiRequest<User> request) {
        User user = request.getData();
        return new ApiResponse<>("SUCCESS", "User created successfully", user);
    }

    // PUT
    @PutMapping(value = "/update",
                consumes = {MediaType.APPLICATION_JSON_VALUE, MediaType.APPLICATION_XML_VALUE},
                produces = {MediaType.APPLICATION_JSON_VALUE, MediaType.APPLICATION_XML_VALUE})
    public ApiResponse<User> updateUser(@RequestBody ApiRequest<User> request) {
        User user = request.getData();
        return new ApiResponse<>("SUCCESS", "User updated successfully", user);
    }

    // DELETE
    @DeleteMapping(value = "/delete/{name}",
                   produces = {MediaType.APPLICATION_JSON_VALUE, MediaType.APPLICATION_XML_VALUE})
    public ApiResponse<String> deleteUser(@PathVariable("name") String name) {
        return new ApiResponse<>("SUCCESS", "User deleted successfully", name);
    }

    // PATCH
    @PatchMapping(value = "/patch",
                  consumes = {MediaType.APPLICATION_JSON_VALUE, MediaType.APPLICATION_XML_VALUE},
                  produces = {MediaType.APPLICATION_JSON_VALUE, MediaType.APPLICATION_XML_VALUE})
    public ApiResponse<User> patchUser(@RequestBody ApiRequest<User> request) {
        User user = request.getData();
        return new ApiResponse<>("SUCCESS", "User partially updated", user);
    }

/////////////////

4>What do you understand from @Autowired annotation?

The @Autowired annotation in Spring is a mechanism for dependency injection. 
It tells the Spring framework to automatically inject an object into a bean, 
which is a key part of what's known as Inversion of Control (IoC).

How It Works

Instead of you manually creating and managing an object's dependencies, 
@Autowired lets Spring do it for you. When Spring encounters @Autowired 
on a field, constructor, or setter method, it searches its application 
context for a bean that matches the type of the dependency and 
automatically provides it.

The @Autowired annotation in Spring is a mechanism for dependency 
injection. It tells the Spring framework to automatically inject an 
object into a bean, which is a key part of what's known as Inversion 
of Control (IoC).

How It Works

Instead of you manually creating and managing an object's dependencies, 
@Autowired lets Spring do it for you. When Spring encounters @Autowired 
on a field, constructor, or setter method, it searches its application 
context for a bean that matches the type of the dependency and 
automatically provides it.

Example

Imagine a UserService that needs a UserRepository to function. Instead 
of you creating the UserRepository yourself within the UserService class, 
you can let Spring inject it.

@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    // ... methods that use userRepository ...
}

In this example, @Autowired on the userRepository field tells Spring: 
"When you create a UserService bean, please find an existing UserRepository 
bean in your context and assign it to this field." This practice 
decouples your classes, making the code more modular and easier 
to test.

/////////////////

5>Explain the differences between JSR-250 Annotations and @Qualifier annotations.

/////////////////

6>Explain the Annotation-based container configuration.

/////////////////

7>Highlight the role of @SpringBootApplication.

/////////////////

8>Is it possible to send an Object as the response of the Controller handler method?

/////////////////

9>Explain @ModelAttribute?

///////////////// 

10>Tell us the difference between the Configuration types XML and Annotation?
    
/////////////////