
Spring Hibernate Interview Questions

/////////////////////////

1>What are the ways to access Hibernate by using Spring?

1>Spring Data JPA (Recommended for modern applications):

1a>This is the preferred approach for new projects. Spring Data JPA 
significantly simplifies data access by providing powerful repository 
abstractions.
1b>You define interfaces that extend Spring Data JPA's JpaRepository 
(or other repository interfaces like CrudRepository).
1c>Spring automatically generates the implementation for these interfaces 
at runtime, handling common CRUD operations and allowing for custom 
queries based on method names or @Query annotations.
1d>Hibernate acts as the underlying JPA provider, managing the 
object-relational mapping and database interactions.

@Repository
public interface CustomerRepository extends JpaRepository<Customer, Long> {

    // ================= Derived Queries overridden with @Query =================

    @Query("SELECT c FROM Customer c WHERE c.lastName = :lastName")
    List<Customer> findByLastName(@Param("lastName") String lastName);

    @Query("SELECT c FROM Customer c WHERE c.gender = :gender")
    List<Customer> findByGender(@Param("gender") String gender);
    
------------------

2>ative Hibernate SessionFactory Integration:

2a>This method directly exposes Hibernate's SessionFactory within 
the Spring container.
2b>You configure LocalSessionFactoryBean in your Spring configuration 
(either Java-based or XML-based) to set up the SessionFactory.
2c>You then inject the SessionFactory into your DAOs (Data Access Objects) 
and use it to obtain Session instances for performing database operations.
2d>While still supported, this approach is less common in new development 
compared to Spring Data JPA, as it requires more boilerplate code for basic operations.

@Repository
public class CustomerDaoImpl implements CustomerDao {

    @Autowired
    private SessionFactory sessionFactory;

    private Session getCurrentSession() {
        return sessionFactory.getCurrentSession();
    }

    @Override
    public Customer save(Customer customer) {
        getCurrentSession().saveOrUpdate(customer);
        return customer;
    }
    
    @Override
    public List<Customer> findByDepartmentNameAndActive(String departmentName, Boolean active) {
        Query<Customer> query = getCurrentSession().createQuery(
                "SELECT c FROM Customer c " +
                "JOIN Department d ON c.deptId = d.id " +
                "WHERE d.name = :deptName AND c.active = :active " +
                "ORDER BY c.salary DESC",
                Customer.class);
        query.setParameter("deptName", departmentName);
        query.setParameter("active", active);
        return query.getResultList();
    }

    @Override
    public int countByDepartmentAndSalaryThreshold(Long departmentId, BigDecimal salary) {
        Query<Long> query = getCurrentSession().createQuery(
                "SELECT COUNT(c) FROM Customer c WHERE c.deptId = :deptId AND c.salary > :salary",
                Long.class);
        query.setParameter("deptId", departmentId);
        query.setParameter("salary", salary);
        return query.getSingleResult().intValue();
    }

/////////////////////////

what entity management is this referring to?  is this saying spring data jdbc 
lack something? lack what?

1>Spring Data JPA (Full entity lifecycle management)
ORM-based: Uses Object-Relational Mapping through JPA providers (like Hibernate)
Entity management: Full entity lifecycle management with persistence contexts

2>Spring Data JDBC
Direct JDBC: Works directly with JDBC, no ORM layer
Simple mapping: Simple object-to-table mapping without complex entity management

-----------------

The provided text is referring to entity management in the context of persistence frameworks, specifically comparing Spring Data JPA and Spring Data JDBC. It's not saying that Spring Data JDBC lacks something, but rather that it takes a different, simpler approach to entity management than Spring Data JPA.

1>Spring Data JPA uses an Object-Relational Mapping (ORM) layer, like Hibernate, to manage the full lifecycle of entities. This includes a persistence context, which is a cache that tracks the state of objects (entities) that are loaded from or saved to the database.

2>Spring Data JDBC, on the other hand, does not use an ORM or a persistence context. It operates more like a simple object-to-table mapper, working directly with JDBC.

2a>No Persistence Context: This is the key difference. Spring Data JDBC doesn't track entity state. When you fetch an object, it's just a Plain Old Java Object (POJO).

2b>Manual Updates: If you modify an object retrieved with Spring Data JDBC, you must explicitly call the save() method on the repository to persist the changes. The framework doesn't automatically detect changes like JPA does.

------------------------

The Connection
1>Spring Data JPA: save, findAll, findById, and deleteById are part of the JpaRepository 
interface provided by Spring Data JPA. You don't need to define them 
yourself because Spring Data JPA automatically generates an implementation 
at runtime that uses an underlying JPA EntityManager.
2>This EntityManager is the core component that manages the persistence 
context and the full entity lifecycle. When you call customerRepository.save(customer), 
Spring Data JPA's generated code uses the EntityManager to perform the 
database operation, ensuring the entity is managed correctly (e.g., 
tracking changes, cascading operations).
3>This is the key connection: JpaRepository methods act as a high-level, 
simplified proxy for the low-level, full entity lifecycle management 
capabilities of the EntityManager and the persistence context.

-----------------

JPA vs. JDBC: The Advantage of JPA
The main advantage of Spring Data JPA over Spring Data JDBC is its handling of 
the entity lifecycle and relationships.
1>Spring Data JPA: As you noted, it provides full entity lifecycle management. 
This means it can automatically handle complex tasks like cascading operations 
(e.g., saving a Customer automatically saves their Address if configured), 
lazy loading of related entities, and dirty checking (automatically updating 
an entity if a change is detected without an explicit save call). All of this 
is managed by the persistence context.
2>Spring Data JDBC: This works directly with the database via JDBC and 
lacks a persistence context. It's a simpler, more direct approach. You have 
to manually manage relationships and update logic. If you save a Customer, 
you must explicitly save their Address separately. This simplicity can 
be an advantage for simpler applications but requires more boilerplate 
code for complex scenarios.

/////////////////////////

2>What is the hibernate configuration file?

/////////////////////////

3>What is hibernate mapping file?

/////////////////////////

4>What is the difference between the Hibernate Session get() and load() method?

/////////////////////////

5>What is hibernate caching? Explain Hibernate first-level cache?

/////////////////////////

6>What will happen if we donâ€™t have a no-args constructor in Entity bean?

/////////////////////////

7>Explain the difference between sorted collection and ordered collection. 
Which one is better, in your opinion?

/////////////////////////

8>Are there any collection types in Hibernate?

/////////////////////////

9>Is it possible to execute a native SQL query in hibernate?

/////////////////////////

10.  What is the benefit of native SQL query support in hibernate?

/////////////////////////
