
Spring Hibernate Interview Questions

/////////////////////////

1>What are the ways to access Hibernate by using Spring?

1>Spring Data JPA (Recommended for modern applications):

1a>This is the preferred approach for new projects. Spring Data JPA 
significantly simplifies data access by providing powerful repository 
abstractions.
1b>You define interfaces that extend Spring Data JPA's JpaRepository 
(or other repository interfaces like CrudRepository).
1c>Spring automatically generates the implementation for these interfaces 
at runtime, handling common CRUD operations and allowing for custom 
queries based on method names or @Query annotations.
1d>Hibernate acts as the underlying JPA provider, managing the 
object-relational mapping and database interactions.

@Repository
public interface CustomerRepository extends JpaRepository<Customer, Long> {

    // ================= Derived Queries overridden with @Query =================

    @Query("SELECT c FROM Customer c WHERE c.lastName = :lastName")
    List<Customer> findByLastName(@Param("lastName") String lastName);

    @Query("SELECT c FROM Customer c WHERE c.gender = :gender")
    List<Customer> findByGender(@Param("gender") String gender);
    
------------------

2>ative Hibernate SessionFactory Integration:

2a>This method directly exposes Hibernate's SessionFactory within 
the Spring container.
2b>You configure LocalSessionFactoryBean in your Spring configuration 
(either Java-based or XML-based) to set up the SessionFactory.
2c>You then inject the SessionFactory into your DAOs (Data Access Objects) 
and use it to obtain Session instances for performing database operations.
2d>While still supported, this approach is less common in new development 
compared to Spring Data JPA, as it requires more boilerplate code for basic operations.

@Repository
public class CustomerDaoImpl implements CustomerDao {

    @Autowired
    private SessionFactory sessionFactory;

    private Session getCurrentSession() {
        return sessionFactory.getCurrentSession();
    }

    @Override
    public Customer save(Customer customer) {
        getCurrentSession().saveOrUpdate(customer);
        return customer;
    }
    
    @Override
    public List<Customer> findByDepartmentNameAndActive(String departmentName, Boolean active) {
        Query<Customer> query = getCurrentSession().createQuery(
                "SELECT c FROM Customer c " +
                "JOIN Department d ON c.deptId = d.id " +
                "WHERE d.name = :deptName AND c.active = :active " +
                "ORDER BY c.salary DESC",
                Customer.class);
        query.setParameter("deptName", departmentName);
        query.setParameter("active", active);
        return query.getResultList();
    }

    @Override
    public int countByDepartmentAndSalaryThreshold(Long departmentId, BigDecimal salary) {
        Query<Long> query = getCurrentSession().createQuery(
                "SELECT COUNT(c) FROM Customer c WHERE c.deptId = :deptId AND c.salary > :salary",
                Long.class);
        query.setParameter("deptId", departmentId);
        query.setParameter("salary", salary);
        return query.getSingleResult().intValue();
    }

/////////////////////////

what entity management is this referring to?  is this saying spring data jdbc 
lack something? lack what?

1>Spring Data JPA (Full entity lifecycle management)
ORM-based: Uses Object-Relational Mapping through JPA providers (like Hibernate)
Entity management: Full entity lifecycle management with persistence contexts

2>Spring Data JDBC
Direct JDBC: Works directly with JDBC, no ORM layer
Simple mapping: Simple object-to-table mapping without complex entity management

-----------------

The provided text is referring to entity management in the context of persistence frameworks, specifically comparing Spring Data JPA and Spring Data JDBC. It's not saying that Spring Data JDBC lacks something, but rather that it takes a different, simpler approach to entity management than Spring Data JPA.

1>Spring Data JPA uses an Object-Relational Mapping (ORM) layer, like Hibernate, to manage the full lifecycle of entities. This includes a persistence context, which is a cache that tracks the state of objects (entities) that are loaded from or saved to the database.

2>Spring Data JDBC, on the other hand, does not use an ORM or a persistence context. It operates more like a simple object-to-table mapper, working directly with JDBC.

2a>No Persistence Context: This is the key difference. Spring Data JDBC doesn't track entity state. When you fetch an object, it's just a Plain Old Java Object (POJO).

2b>Manual Updates: If you modify an object retrieved with Spring Data JDBC, you must explicitly call the save() method on the repository to persist the changes. The framework doesn't automatically detect changes like JPA does.

------------------------

The Connection
1>Spring Data JPA: save, findAll, findById, and deleteById are part of the JpaRepository 
interface provided by Spring Data JPA. You don't need to define them 
yourself because Spring Data JPA automatically generates an implementation 
at runtime that uses an underlying JPA EntityManager.
2>This EntityManager is the core component that manages the persistence 
context and the full entity lifecycle. When you call customerRepository.save(customer), 
Spring Data JPA's generated code uses the EntityManager to perform the 
database operation, ensuring the entity is managed correctly (e.g., 
tracking changes, cascading operations).
3>This is the key connection: JpaRepository methods act as a high-level, 
simplified proxy for the low-level, full entity lifecycle management 
capabilities of the EntityManager and the persistence context.

-----------------

JPA vs. JDBC: The Advantage of JPA
The main advantage of Spring Data JPA over Spring Data JDBC is its handling of 
the entity lifecycle and relationships.
1>Spring Data JPA: As you noted, it provides full entity lifecycle management. 
This means it can automatically handle complex tasks like cascading operations 
(e.g., saving a Customer automatically saves their Address if configured), 
lazy loading of related entities, and dirty checking (automatically updating 
an entity if a change is detected without an explicit save call). All of this 
is managed by the persistence context.
2>Spring Data JDBC: This works directly with the database via JDBC and 
lacks a persistence context. It's a simpler, more direct approach. You have 
to manually manage relationships and update logic. If you save a Customer, 
you must explicitly save their Address separately. This simplicity can 
be an advantage for simpler applications but requires more boilerplate 
code for complex scenarios.

/////////////////////////

2>What is the hibernate configuration file?

The Hibernate configuration file is a file that contains the configuration settings for the Hibernate framework. This file is a central component for an application using Hibernate as it provides the database connection details, dialect information, and mapping file locations, which are essential for Hibernate to function.

The Hibernate configuration file is a file that contains the configuration settings for the Hibernate framework. This file is a central component for an application using Hibernate as it provides the database connection details, dialect information, and mapping file locations, which are essential for Hibernate to function.

Types of Configuration Files
There are two main types of Hibernate configuration files:

1>hibernate.cfg.xml: This is the traditional and most common type of configuration file. It's an XML file that contains all the necessary configuration properties.

2>hibernate.properties: This is a simple Java properties file that can be used as an alternative to the XML file. It contains key-value pairs for the configuration settings.

----------------

Here is an example of what a hibernate.cfg.xml
<hibernate-configuration>
    <session-factory>
        <!-- Database connection properties -->
        <property name="hibernate.connection.driver_class">com.mysql.cj.jdbc.Driver</property>
        <property name="hibernate.connection.url">jdbc:mysql://localhost:3306/testdb</property>
        <property name="hibernate.connection.username">root</property>
        <property name="hibernate.connection.password">password</property>
        
        <!-- Connection pool settings -->
        <property name="hibernate.hikari.maximumPoolSize">10</property>
        <property name="hibernate.hikari.minimumIdle">5</property>
        <property name="hibernate.hikari.connectionTimeout">30000</property>
        <property name="hibernate.hikari.idleTimeout">600000</property>
        <property name="hibernate.hikari.maxLifetime">1800000</property>
        
        <!-- Hibernate properties -->
        <property name="hibernate.dialect">org.hibernate.dialect.MySQL8Dialect</property>
        <property name="hibernate.hbm2ddl.auto">update</property>
        <property name="hibernate.show_sql">true</property>
        <property name="hibernate.format_sql">true</property>
        <property name="hibernate.use_sql_comments">true</property>
        <property name="hibernate.jdbc.batch_size">20</property>
        <property name="hibernate.order_inserts">true</property>
        <property name="hibernate.order_updates">true</property>
        <property name="hibernate.current_session_context_class">org.springframework.orm.hibernate5.SpringSessionContext</property>
        
        <!-- Entity mappings -->
        <mapping class="com.example.entity.Customer"/>
        <!-- Add other entity classes here as needed -->
        
    </session-factory>
</hibernate-configuration>

----------------

referenced in spring-data-jpa applicationContext.xml
    <!-- JPA Entity Manager Factory with hibernate.cfg.xml reference -->
    <bean id="entityManagerFactory" 
          class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean">
        <property name="dataSource" ref="dataSource"/>
        <property name="packagesToScan" value="com.example.entity"/>
        <property name="jpaVendorAdapter">
            <bean class="org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter"/>
        </property>
        <!-- Reference hibernate.cfg.xml for JPA properties -->
        <property name="jpaPropertyMap">
            <map>
                <entry key="hibernate.ejb.cfgfile" value="hibernate.cfg.xml"/>
            </map>
        </property>
        <!-- Override specific properties if needed -->
        <property name="jpaProperties">
            <props>
                <!-- These will override any conflicting properties from hibernate.cfg.xml -->
                <prop key="hibernate.dialect">org.hibernate.dialect.MySQL8Dialect</prop>
                <prop key="hibernate.hbm2ddl.auto">update</prop>
                <prop key="hibernate.show_sql">true</prop>
                <prop key="hibernate.format_sql">true</prop>
                <prop key="hibernate.use_sql_comments">true</prop>
                <prop key="hibernate.jdbc.batch_size">20</prop>
                <prop key="hibernate.order_inserts">true</prop>
                <prop key="hibernate.order_updates">true</prop>
            </props>
        </property>
    </bean>

----------------

referenced in spring session factory applicationContext.xml
    <!-- Hibernate SessionFactory with hibernate.cfg.xml reference -->
    <bean id="sessionFactory" 
          class="org.springframework.orm.hibernate5.LocalSessionFactoryBean">
        <property name="dataSource" ref="dataSource"/>
        <property name="packagesToScan" value="com.example.entity"/>
        <!-- Reference hibernate.cfg.xml file -->
        <property name="configLocation" value="classpath:hibernate.cfg.xml"/>
        <!-- You can still override specific properties if needed -->
        <property name="hibernateProperties">
            <props>
                <!-- These will override any conflicting properties from hibernate.cfg.xml -->
                <prop key="hibernate.current_session_context_class">org.springframework.orm.hibernate5.SpringSessionContext</prop>
            </props>
        </property>
    </bean> 

/////////////////////////

3>What is hibernate mapping file?

update hibernate.cfg.xml to include
<mapping resource="com/example/entity/Customer.hbm.xml"/>

--------------

<hibernate-mapping package="com.example.entity">
    
    <class name="Customer" table="customer">
        
        <!-- Primary Key -->
        <id name="id" column="id" type="java.lang.Long">
            <generator class="identity"/>
        </id>
        
        <!-- Basic Properties -->
        <property name="firstName" column="first_name" type="string" not-null="true"/>
        <property name="lastName" column="last_name" type="string" not-null="true"/>
        <property name="gender" column="gender" type="string"/>
        <property name="street" column="street" type="string"/>
        <property name="city" column="city" type="string"/>
        <property name="state" column="state" type="string"/>
        
        <!-- BigDecimal with precision and scale -->
        <property name="salary" column="salary" type="big_decimal" precision="10" scale="2"/>
        
        <!-- Boolean property -->
        <property name="active" column="active" type="boolean"/>
        
        <!-- Foreign Key reference -->
        <property name="deptId" column="dept_id" type="java.lang.Long"/>
        
        <!-- LocalDateTime property -->
        <property name="createdDate" column="created_date" type="java.time.LocalDateTime"/>
        
    </class>
    
</hibernate-mapping>

/////////////////////////

4>What is the difference between the Hibernate Session get() and load() method?

Session.get()
1>Loading Behavior: Performs an eager load. When get() is called, Hibernate 
immediately executes a SQL SELECT query to retrieve the data from the 
database and returns the actual persistent object.
2>Return Type: eturns the actual persistent object if found, or null if no 
matching record exists in the database.
3>Error Handling: Returns null if the entity with the specified ID is not found 
in the database. No exception is thrown in this scenario.
		
-------------------------

Session.load()
1>Loading Behavior: Performs a lazy load. When load() is called, Hibernate 
does not immediately hit the database. Instead, it returns a proxy object 
(a CGLIB or Javassist-generated subclass) with the given identifier. The 
actual data is only loaded from the database when a method (other than 
getId()) or a property of the proxy object is accessed.
2>Return Type: Returns a proxy object. If no matching record exists, 
an ObjectNotFoundException is thrown when a property of the proxy is 
accessed, not when load() is initially called.
3>Error Handling: Throws an ObjectNotFoundException if the entity with 
the specified ID does not exist when a method or property of the returned 
proxy object is accessed.

--------------------------

https://www.digitalocean.com/community/tutorials/hibernate-session-get-vs-load-difference-with-examples
public class HibernateGetVsLoad {

	public static void main(String[] args) {
		
		//Prep Work
		SessionFactory sessionFactory = HibernateUtil.getSessionFactory();
		Session session = sessionFactory.openSession();
		Transaction tx = session.beginTransaction();
		
		//Get Example
		Employee emp = (Employee) session.get(Employee.class, new Long(2));
		System.out.println("Employee get called");
		System.out.println("Employee ID= "+emp.getId());
		System.out.println("Employee Get Details:: "+emp+"\n");
		
		//load Example
		Employee emp1 = (Employee) session.load(Employee.class, new Long(1));
		System.out.println("Employee load called");
		System.out.println("Employee ID= "+emp1.getId());
		System.out.println("Employee load Details:: "+emp1+"\n");
		
		//Close resources
		tx.commit();
		sessionFactory.close();
	}
}

----------------

When I execute above code, it produces following output.
Hibernate: select employee0_.emp_id as emp_id1_1_0_, employee0_.emp_name as emp_name2_1_0_, employee0_.emp_salary as emp_sala3_1_0_, address1_.emp_id as emp_id1_0_1_, address1_.address_line1 as address_2_0_1_, address1_.city as city3_0_1_, address1_.zipcode as zipcode4_0_1_ from EMPLOYEE employee0_ left outer join ADDRESS address1_ on employee0_.emp_id=address1_.emp_id where employee0_.emp_id=?
Employee get called
Employee ID= 2
Employee Get Details:: Id= 2, Name= David, Salary= 200.0, {Address= AddressLine1= Arques Ave, City=Santa Clara, Zipcode=95051}

Employee load called
Employee ID= 1
Hibernate: select employee0_.emp_id as emp_id1_1_0_, employee0_.emp_name as emp_name2_1_0_, employee0_.emp_salary as emp_sala3_1_0_, address1_.emp_id as emp_id1_0_1_, address1_.address_line1 as address_2_0_1_, address1_.city as city3_0_1_, address1_.zipcode as zipcode4_0_1_ from EMPLOYEE employee0_ left outer join ADDRESS address1_ on employee0_.emp_id=address1_.emp_id where employee0_.emp_id=?
Employee load Details:: Id= 1, Name= Pankaj, Salary= 100.0, {Address= AddressLine1= Albany Dr, City=San Jose, Zipcode=95129}
-------------------
From the output it’s clear that get() returns the object by fetching it from 
database or from hibernate cache whereas load() just returns the reference of 
an object that might not actually exists, it loads the data from database or 
cache only when you access other properties of the object.

/////////////////////////

5>What is hibernate caching? Explain Hibernate first-level cache?

Hibernate caching is a mechanism used to improve the performance of applications 
by reducing the number of database interactions. It stores frequently accessed 
data in memory, allowing Hibernate to retrieve it from the cache instead of 
repeatedly querying the database. This significantly reduces latency and 
improves overall application responsiveness.

1>Hibernate First-Level Cache (Session Cache)
The Hibernate first-level cache, also known as the Session cache, is a 
mandatory, built-in caching mechanism that operates at the session level. 
This means:

2>Session-Specific Scope:
    Each Hibernate Session object maintains its own independent first-level 
    cache. Data stored in this cache is accessible only within that specific 
    session.

3>Automatic Management:
Hibernate automatically manages the first-level cache; it is enabled by default 
and cannot be disabled.

4>Entity Storage:
When an entity is loaded from the database using a Session, it is automatically 
stored in the first-level cache.

https://medium.com/swlh/what-is-hibernate-caching-introduction-of-level-1-level-2-cache-8ea7339a5052
so when you query an entity or object, for the very first time it is retrieved 
from the database and stored into the first-level cache (associated with the 
hibernate session). If we query for the same entity or object again with the 
same session object, it will be loaded from cache and no SQL query will be 
executed.

/////////////////////////

In Hibernate (an ORM framework for Java), caching improves performance 
by reducing the number of database queries. Instead of fetching the 
same data multiple times from the database, Hibernate stores it in 
memory and reuses it.
-----------------------------
1️⃣ First-Level Cache (Session Cache)
1a>Scope: Exists per Hibernate Session (org.hibernate.Session).
1b>Enabled by default (cannot be disabled).
1c>Stores objects associated with the current session.
1d>If you fetch the same entity multiple times in the same session, 
Hibernate returns the cached object instead of hitting the database again.
-----------------------------
2️⃣ Second-Level Cache (SessionFactory Cache)
2a>Scope: Shared across all sessions from a SessionFactory.
2b>Not enabled by default — you must configure it.
2c>Requires a cache provider (e.g., Ehcache, Infinispan, OSCache).
2d>Stores entities, collections, or queries at the SessionFactory level, 
so that multiple sessions can reuse cached data.
------------------------------
Example behavior:
Session session = sessionFactory.openSession();
// First time: SQL query executed, data loaded from DB
Employee emp1 = session.get(Employee.class, 1);
// Second time: No SQL query, returned from session cache
Employee emp2 = session.get(Employee.class, 1);
System.out.println(emp1 == emp2); // true (same object from cache)

/////////////////////////

6>What will happen if we don’t have a no-args constructor in Entity bean?
in Hibernate?

/////////////////////////

7>Explain the difference between sorted collection and ordered collection. 
Which one is better, in your opinion? in Hibernate?

/////////////////////////

8>Are there any collection types in Hibernate?

/////////////////////////

9>Is it possible to execute a native SQL query in hibernate?

/////////////////////////

10.  What is the benefit of native SQL query support in hibernate?

/////////////////////////
