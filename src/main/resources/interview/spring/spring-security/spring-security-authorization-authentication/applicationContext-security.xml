<?xml version="1.0" encoding="UTF-8"?>
<beans:beans xmlns="http://www.springframework.org/schema/security"
             xmlns:beans="http://www.springframework.org/schema/beans"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="
              http://www.springframework.org/schema/security
              https://www.springframework.org/schema/security/spring-security.xsd
              http://www.springframework.org/schema/beans
              https://www.springframework.org/schema/beans/spring-beans.xsd">
              
    <!--  
    applicationContext-security.xml
	This is the XML-based Spring Security config that enables annotation-based 
	method security.
	//////////////////
	{noop} means "plain text password" (no encoding) for demo purposes.
	Both in-XML user definitions and your CustomUserDetailsService will work, 
	but here I showed the in-memory config. You can swap it with DB + 
	UserDetailsService as below.
    -->

    <!-- Enable @PreAuthorize / @PostAuthorize -->
    <global-method-security pre-post-annotations="enabled" />

	<!--  
	Here no CustomUserDetailsService is involved at all.
	1>Spring creates an in-memory UserDetailsService bean behind the scenes.
	2>When authentication happens (form login, basic auth), Spring Security 
	calls loadUserByUsername("admin") or "user" on the in-memory 
	UserDetailsService, which simply looks up those <user> entries.
	3>So the loadUserByUsername() method in your CustomUserDetailsService 
	is never called.
	////////////////////////////
	Where do name="admin" / name="user" come from?
	In Case 1: they come directly from XML <user> definitions.
	Case 1 = in-memory users, no DB, your custom service isnâ€™t touched.
	-->
    <!-- Authentication configuration -->
    <authentication-manager>
        <authentication-provider>
            <user-service>
                <user name="admin" password="{noop}admin123" authorities="ROLE_ADMIN"/>
                <user name="user" password="{noop}user123" authorities="ROLE_USER"/>
            </user-service>
        </authentication-provider>
    </authentication-manager>

	<!--
	We need <intercept-url> to define which URLs (or web resources) are protected 
	and what authorization rules apply to them. It's a fundamental part of a 
	security framework like Spring Security, allowing you to create a security 
	policy by mapping specific URL patterns to required access permissions.
    /////////////////////////////////
	How it Works
	The <intercept-url> element acts as a security filter. When an incoming 
	request matches a defined URL pattern, the framework checks the associated 
	access rule.

	1>URL Matching: The pattern attribute specifies the URL path to be secured 
	(e.g., /api/v1/resources/admin).
	2>Access Control: The access attribute specifies the permissions required 
	to access that URL. This typically uses expressions like hasRole() or 
	isAuthenticated(). If the user's roles or permissions don't match, the 
	request is blocked, and the user is denied authorization.
	/////////////////////////////////
	Why it's Necessary
	Without <intercept-url>, all your application's URLs would be either 
	completely open or completely locked down, with no granularity. It enables 
	you to implement a fine-grained security model, such as:

	1>Restricting Admin Access: As in your example, only users with the 
	ADMIN role can access /api/v1/resources/admin.
	2>Controlling User-Level Access: Allowing both ADMIN and USER roles 
	to access /api/v1/resources/public.
	3>Allowing Public Access: You could specify access="permitAll" for public 
	pages like a home page or login form, which don't require any authentication.  
	-->
    <!-- Authorization via URL patterns (extra protection on endpoints) -->
    <http>
        <intercept-url pattern="/api/v1/resources/admin" access="hasRole('ADMIN')" />
        <intercept-url pattern="/api/v1/resources/public" access="hasAnyRole('ADMIN','USER')" />
        <form-login />
        <http-basic />
        <logout />
    </http>

</beans:beans>