
Spring Security Interview Questions

spring-security.txt

///////////////////////////////////////

1>What is the security filter chain in Spring Security? and java example 

The security filter chain in Spring Security is a series of filters 
that process incoming HTTP requests to apply security measures. 

Each filter in the chain has a specific purpose, such as authentication, 
authorization, or handling exceptions. When an HTTP request arrives, 
it passes through this chain of filters in a predefined order. 

If a filter determines that the request is not authorized or authenticated, 
it can reject the request, preventing it from reaching the application's 
resources.

///////////////////////////////////////

2>Describe some of the predefined filters used by Spring Security. What are 
their functions, and in which order do they occur? and java example 

Spring Security uses a chain of filters to handle a request's security aspects, 
like authentication and authorization. Each filter in the chain has a specific 
purpose and operates in a predetermined order. While you can customize and add 
your own, here are some key predefined filters and their functions:

Predefined Filters and Functions

1>SecurityContextPersistenceFilter: This is typically the first filter in the 
chain. Its job is to populate the SecurityContextHolder with the user's 
authentication information, usually from the HTTP session. It ensures the 
security context is available to other filters and components for the duration 
of the request.

2>UsernamePasswordAuthenticationFilter: This filter processes form-based logins. 
It extracts the username and password from the request and attempts to authenticate 
the user. If successful, it creates an Authentication object and stores it in 
the SecurityContextHolder.

3>LogoutFilter: This filter handles logout requests. It's responsible for invalidating 
the session, clearing the SecurityContext, and redirecting the user to a specified 
logout success URL.

4>ExceptionTranslationFilter: This filter is crucial for handling security-related 
exceptions. It catches AuthenticationException and AccessDeniedException and then 
either redirects the user to an authentication entry point (like a login page) 
or invokes an AccessDeniedHandler to handle the error.

5>FilterSecurityInterceptor: This is one of the last filters in the chain. It 
enforces authorization rules. It inspects the request and checks if the authenticated 
user has the necessary permissions to access the requested resource. If not, it 
throws an AccessDeniedException.
    
///////////////////////////////////////

3>How will you implement a custom filter in Spring Security? and java example 

To implement a custom filter in Spring Security, you'll need to create a 
filter class, configure it to be managed by Spring, and then add it to 
the filter chain at the appropriate position. A custom filter is essential 
when you need to perform actions like API key validation, token-based 
authentication, or logging before the request reaches the application's endpoints.

Step 1: Create the Custom Filter Class
First, create a class that extends OncePerRequestFilter. This abstract class 
guarantees that your filter's doFilterInternal method will only be called 
once per request, which prevents redundant processing.

This example filter CustomAuthenticationFilter checks for a header named X-API-Key. If the header 
exists and its value is "my-secret-key", the filter allows the request 
to proceed. Otherwise, it sends an HTTP 401 Unauthorized response.

Step 2: Configure the Filter in Spring Security
Next, you need to register your custom filter CustomAuthenticationFilterConfig.java with Spring's security 
configuration. You'll use the SecurityFilterChain bean to define 
the order of the filters.

///////////////////////////////////////

4>Is security a cross-cutting concern? How is it implemented? and java example 

Yes, security is a cross-cutting concern. A cross-cutting concern is a feature 
or aspect of a software system that affects multiple parts of the application 
but can't be cleanly separated into a single, isolated module. Security, like 
logging, transaction management, and caching, touches almost every component 
of an application, from authentication and authorization to data validation 
and communication protocols.

How It's Implemented
Implementing security as a cross-cutting concern typically involves using AOP 
(Aspect-Oriented Programming) principles, even if not using a formal AOP 
framework. The core idea is to separate the security logic (the "aspect") 
from the main business logic (the "join points"). This separation helps avoid 
scattering security code throughout the application, which would make the 
system harder to maintain, understand, and secure.
The implementation often follows these steps:

1>Interception: The application intercepts requests or method calls at specific 
points. These points, called join points, are where the security logic needs 
to be applied.

2>Aspects: A dedicated module or class, the aspect, contains the security logic. 
This could be a set of rules for authentication or a check for user permissions.

3>Weaving: The aspect is then "woven" into the application's code at the join 
points. This weaving can happen at different stages:
a>Compile-time: The security code is injected directly into the bytecode.
b>Load-time: A special class loader modifies the bytecode as it's being loaded 
into the JVM.
c>Run-time: The interception is handled by proxies or dynamic proxies, which are 
objects that wrap the target object and apply the security logic before or after 
the method call.

In Java, a common way to implement security as a cross-cutting concern is by using 
a proxy pattern or a framework like Spring Security.
Proxy Pattern Example

Without a framework, you can use the proxy pattern to wrap a business object with 
security checks. Let's say we have a ReportService with a generateReport() method.

In this example, the SecuredReportServiceProxy is the "aspect" that contains the 
security logic. It intercepts the generateReport() method call and applies the 
security check before delegating the call to the actual ReportServiceImpl. The 
business logic remains clean and unaware of the security implementation.

///////////////////////////////////////

5>Explain which security annotations are allowed to use SpEL. and what is SpEL. 
and  java example 

SpEL, short for Spring Expression Language, is a powerful expression 
language used in the Spring Framework. It allows you to query and 
manipulate an object graph at runtime. It's similar to other expression 
languages like OGNL and MVEL, but it's specifically designed for Spring.

Security Annotations and SpEL
The following security annotations in Spring Security are allowed to use SpEL:
1>@PreAuthorize: This annotation is used to decide whether a method can be 
invoked. The SpEL expression is evaluated before the method is called. For 
example, you can check if the currently authenticated user has a specific role.

2>@PostAuthorize: This annotation is used to decide whether the result of a 
method invocation can be returned. The SpEL expression is evaluated after 
the method has executed but before the result is returned to the caller. 
This is useful for making decisions based on the returned object.

3>@PreFilter: This annotation is used to filter collections before a method 
is executed. The SpEL expression is applied to each element of the collection. 
It's often used with method parameters that are collections or arrays.

4>@PostFilter: This annotation is used to filter collections after a method has 
executed. The SpEL expression is applied to each element of the returned 
collection, effectively removing elements that don't meet the criteria.

example

    // @PreAuthorize example: checks if the user has the 'ADMIN' role before the method runs.
    @PreAuthorize("hasRole('ADMIN')")
    public String createOrder(String orderId) {
        // Method logic to create an order
        return "Order " + orderId + " created successfully.";
    }

    // @PostAuthorize example: checks if the returned order's owner matches the current user's username.
    @PostAuthorize("returnObject.owner == authentication.name")
    public Order getOrderById(String orderId) {
        // This is a placeholder. In a real application, this would fetch an order from a database.
        Order order = new Order(orderId, "user123");
        return order;
    }

///////////////////////////////////////

6>Explain the differences between authorization and authentication. and java example

spring-security-authorization-authentication
AuthorizationAuthenticationExample.java

Authentication vs. Authorization

Authentication is the process of verifying who a user is. It's the act of 
validating a user's identity, usually by requiring them to provide 
credentials like a username and password. Think of it as a bouncer 
at a club checking your ID to confirm you are who you say you are.

Authorization is the process of determining what a user is allowed to do. 
Once a user's identity is authenticated, authorization checks their 
permissions to access specific resources or perform certain actions. 
This is like the bouncer letting you into the club, but only giving 
you access to the general admission area, not the VIP section.

Here's a simple analogy to summarize the difference:
Authentication asks: "Are you who you say you are?"
Authorization asks: "What are you allowed to do here?"

A common way to see these two concepts in action in a Java application 
is through a web application using a framework like Spring Security.
Authentication
In Spring Security, authentication is often handled by a UserDetailsService 
and an AuthenticationManager. The UserDetailsService is responsible for 
loading user-specific data, and the AuthenticationManager is responsible 
for validating the credentials.

When a user tries to log in, Spring Security's Authentication process 
uses this UserDetailsService to find the user and then compares the 
provided password with the one in the database. If they match, the user 
is authenticated.

Authorization
After a user is authenticated, authorization determines what they can 
access. This is typically managed using roles or permissions. In Spring 
Security, this is often done using @PreAuthorize annotations or configuration 
in a security filter chain.

In this example, a user who has successfully authenticated can only access 
the /admin endpoint if their assigned role includes ADMIN. If they only 
have the USER role, they will be denied authorization to access that 
specific resource, even though they are authenticated.

///////////////////////////////////////

7>Why do we need intercept-URL?

    <http>
        <intercept-url pattern="/api/v1/resources/admin" access="hasRole('ADMIN')" />
        <intercept-url pattern="/api/v1/resources/public" access="hasAnyRole('ADMIN','USER')" />
        <form-login />
        <http-basic />
        <logout />
    </http>
    
We need <intercept-url> to define which URLs (or web resources) are protected 
and what authorization rules apply to them. It's a fundamental part of a 
security framework like Spring Security, allowing you to create a security 
policy by mapping specific URL patterns to required access permissions.

How it Works

The <intercept-url> element acts as a security filter. When an incoming 
request matches a defined URL pattern, the framework checks the associated 
access rule.

1>URL Matching: The pattern attribute specifies the URL path to be secured 
(e.g., /api/v1/resources/admin).

2>Access Control: The access attribute specifies the permissions required 
to access that URL. This typically uses expressions like hasRole() or 
isAuthenticated(). If the user's roles or permissions don't match, the 
request is blocked, and the user is denied authorization.

Why it's Necessary

Without <intercept-url>, all your application's URLs would be either 
completely open or completely locked down, with no granularity. It enables 
you to implement a fine-grained security model, such as:

1>Restricting Admin Access: As in your example, only users with the 
ADMIN role can access /api/v1/resources/admin.

2>Controlling User-Level Access: Allowing both ADMIN and USER roles 
to access /api/v1/resources/public.

3>Allowing Public Access: You could specify access="permitAll" for public 
pages like a home page or login form, which don't require any authentication.

///////////////////////////////////////

8>Explain security context.  and some good spring java example

What is Security Context?
Security Context is a core concept in Spring Security that holds 
security information about the current execution thread. It contains 
authentication details of the currently authenticated user and is 
accessible throughout the application during request processing.
Key Components
1. SecurityContext
Container for security information
Holds the Authentication object
Managed by SecurityContextHolder

2. SecurityContextHolder
Static utility class that provides access to SecurityContext
Uses ThreadLocal by default to store context per thread
Three storage strategies:

MODE_THREADLOCAL (default)
MODE_INHERITABLETHREADLOCAL
MODE_GLOBAL

3. Authentication Object
Represents the authenticated user
Contains:
Principal (usually UserDetails)
Credentials (password, tokens)
Authorities (roles/permissions)
Authentication status

Best Practices
Never store SecurityContext in static variables - Use SecurityContextHolder properly
Clear context after processing - Especially in custom filters
Use method-level security for fine-grained control
Validate authentication state before accessing user details
Handle authentication failures gracefully
Use @Transactional appropriately with security methods
Test security configurations thoroughly

Security Context Lifecycle
Authentication Filter captures credentials
Authentication Manager validates credentials
Authentication Provider performs actual authentication
SecurityContext is populated with Authentication object
Request processing continues with security context available
SecurityContextHolder clears context after request completion

///////////////////////////////////////

9>Who is responsible for managing the life-cycle of filter bean in Spring?

The Spring IoC (Inversion of Control) container is responsible for managing 
the lifecycle of a filter bean. When a filter is defined as a Spring bean, 
the Spring container handles its instantiation, dependency injection, and 
destruction, just like it does for any other bean.

The Spring container manages a bean's lifecycle through a series of steps:

1>Instantiation: The container creates an instance of the filter class, 
typically by calling its default constructor.

2>Dependency Injection: The container injects any dependencies that the 
filter requires (e.g., using @Autowired).

3>Initialization: After dependencies are set, the container may call 
initialization methods. This can be done through interfaces like 
InitializingBean (with the afterPropertiesSet() method), or through 
annotations like @PostConstruct. This is a good time for a filter to 
perform any setup tasks.

4>Ready for use: The filter is now fully initialized and ready to be used to process requests.

5>Destruction: When the Spring container is shut down, it calls destruction 
methods on the bean. This is handled by interfaces like DisposableBean 
(with the destroy() method) or annotations like @PreDestroy. This is where 
a filter can perform cleanup tasks.

It's important to note the distinction between 
a filter managed by the Spring container 
and one managed by the servlet container. 

    <!--
    Filter Managed by the Servlet Container
	You can configure a filter managed by the servlet container using a web.xml 
	deployment descriptor. This approach is standard for all servlet containers 
	and doesn't involve Spring at all. You define the filter, map it to a URL 
	pattern, and specify its initialization parameters.  
    -->
    <filter>
        <filter-name>servletContainerFilter</filter-name>
        <filter-class>com.example.filters.ServletContainerManagedFilter</filter-class>
        <init-param>
            <param-name>param1</param-name>
            <param-value>value1</param-value>
        </init-param>
    </filter>

    <filter-mapping>
        <filter-name>servletContainerFilter</filter-name>
        <url-pattern>/api/*</url-pattern>
    </filter-mapping>
    
    <!--
    Filter Managed by the Spring Container
	To have a filter managed by the Spring container in an XML-based configuration, 
	you define it as a bean in your Spring application context file 
	(applicationContext.xml). You then use a special bean, 
	org.springframework.web.filter.DelegatingFilterProxy, to bridge the servlet 
	container's filter chain to your Spring-managed filter bean.
	To use this, you also need to define the DelegatingFilterProxy in your 
	web.xml:  
    -->
	<filter>
        <filter-name>delegatingFilterProxy</filter-name>
        <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
    </filter>

    <filter-mapping>
        <filter-name>delegatingFilterProxy</filter-name>
        <url-pattern>/api/*</url-pattern>
    </filter-mapping>

///////////////////////////////////////

10>What is delegating filter proxy in Spring Security?

The DelegatingFilterProxy is a special jakarta.servlet.Filter implementation 
provided by Spring Security that bridges the gap between the servlet container's 
lifecycle and the Spring application context. Its primary purpose is to allow 
a standard servlet filter chain, which is managed by the servlet container, 
to delegate to a Spring-managed bean that implements the Filter interface.

How it Works

1>Servlet Container Registers DelegatingFilterProxy: In the web.xml or via a 
FilterRegistrationBean in Spring Boot, you register a DelegatingFilterProxy 
as a normal servlet filter. This is the only part of the filter chain that 
the servlet container knows about directly.

2>Request Arrives: When a web request arrives, the servlet container 
processes its filter chain and eventually calls the doFilter method of the 
DelegatingFilterProxy.

3>Proxy Delegates: The DelegatingFilterProxy then looks up a bean in the 
Spring application context that is the actual security filter chain. By 
default, it looks for a bean named springSecurityFilterChain.

4>Spring Manages the Chain: This springSecurityFilterChain bean is a 
FilterChainProxy, which is the core of Spring Security's filter management. 
It contains an ordered list of all the individual security filters 
(e.g., UsernamePasswordAuthenticationFilter, ExceptionTranslationFilter, 
FilterSecurityInterceptor).

5>Request is Processed: The DelegatingFilterProxy delegates the request to 
the FilterChainProxy, which then runs the request through each of the 
security filters in the correct order.
    
This delegation is crucial because it allows the entire Spring Security 
filter chain to be managed by the Spring container. This means all the 
security filters can leverage Spring's powerful features like dependency 
injection, AOP, and lifecycle management, which would not be possible 
if they were simple servlet filters.

    <bean id="headerFilter" class="com.example.filters.HeaderFilter"/>
    <bean id="loggingFilter" class="com.example.filters.LoggingFilter"/>
    <bean id="authenticationFilter" class="com.example.filters.AuthenticationFilter"/>

    <bean id="springSecurityFilterChain" class="org.springframework.security.web.FilterChainProxy">
        <constructor-arg>
            <list>
                <bean class="org.springframework.security.web.DefaultSecurityFilterChain">
                    <constructor-arg value="/**"/>
                    <constructor-arg>
                        <list>
                            <ref bean="headerFilter"/>
                            <ref bean="loggingFilter"/>
                            <ref bean="authenticationFilter"/>
                        </list>
                    </constructor-arg>
                </bean>
            </list>
        </constructor-arg>
    </bean>
    
///////////////////////////////////////

Spring interview questions cover a wide range of Spring concepts. You must be familiar with all of them to pass the interview. We hope that these sample Spring interview questions will help you with your preparations.


