<beans:beans xmlns="http://www.springframework.org/schema/security"
             xmlns:beans="http://www.springframework.org/schema/beans"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xmlns:context="http://www.springframework.org/schema/context"
             xsi:schemaLocation="
                http://www.springframework.org/schema/beans
                http://www.springframework.org/schema/beans/spring-beans.xsd
                http://www.springframework.org/schema/context
                http://www.springframework.org/schema/context/spring-context.xsd
                http://www.springframework.org/schema/security
                http://www.springframework.org/schema/security/spring-security.xsd">

    <!-- Enable method level security -->
    <global-method-security pre-post-annotations="enabled" 
                           secured-annotations="enabled" 
                           jsr250-annotations="enabled" />

    <!-- HTTP Security Configuration -->
    <http auto-config="true" use-expressions="true">
        <!-- URL Access Rules -->
        <intercept-url pattern="/login" access="permitAll" />
        <intercept-url pattern="/logout" access="permitAll" />
        <intercept-url pattern="/public/**" access="permitAll" />
        <intercept-url pattern="/css/**" access="permitAll" />
        <intercept-url pattern="/js/**" access="permitAll" />
        <intercept-url pattern="/images/**" access="permitAll" />
        <intercept-url pattern="/admin/**" access="hasRole('ADMIN')" />
        <intercept-url pattern="/user/**" access="hasAnyRole('USER','ADMIN')" />
        <intercept-url pattern="/**" access="isAuthenticated()" />

        <!-- Form Login Configuration -->
        <form-login login-page="/login"
                   login-processing-url="/authenticate" 
                   default-target-url="/dashboard"
                   authentication-failure-url="/login?error=true"
                   username-parameter="username"
                   password-parameter="password" />

        <!-- Logout Configuration -->
        <logout logout-url="/logout"
               logout-success-url="/login?logout=true"
               delete-cookies="JSESSIONID"
               invalidate-session="true" />

        <!-- Session Management -->
        <session-management session-fixation-protection="changeSessionId">
            <concurrency-control max-sessions="1" 
                               error-if-maximum-exceeded="false"
                               expired-url="/login?expired=true" />
        </session-management>

        <!-- CSRF Protection -->
        <csrf disabled="false"/>

        <!-- Remember Me -->
        <remember-me key="uniqueAndSecret" 
                    token-validity-seconds="86400"
                    user-service-ref="userDetailsService" />

        <!-- Custom Access Denied Handler -->
        <access-denied-handler error-page="/access-denied" />

        <!-- Security Headers -->
        <headers>
            <cache-control />
            <content-type-options />
            <frame-options policy="DENY" />
            <xss-protection />
        </headers>
    </http>

    <!--
    Summary of Authentication Provider Usage
	The key points about multiple authentication providers:
	////////////////////
	1>Sequential Processing: Spring Security tries each provider in the exact 
	order they appear in the XML configuration
	2>First Success Wins: Once a provider successfully authenticates a user, 
	the authentication chain stops - subsequent providers are ignored
	3>Fallback on Failure: If a provider fails authentication (throws 
	AuthenticationException), Spring moves to the next provider
	4>Common Use Cases:
	4a>Development vs Production: In-memory for dev, database for prod
	4b>Enterprise Multi-Source: LDAP for employees, database for customers
	4c>Gradual Migration: Old system fallback while migrating to new auth
	4d>Emergency Access: Backup authentication method for critical situations
	5>Real-World Example Flow:
		User Login → Custom Provider (LDAP) → Success? → Done
                  ↓ (Failed)
           Database Provider → Success? → Done
                  ↓ (Failed)
           In-Memory Provider → Success/Fail → Done
    //////////////////////////////
    Best Practice: In production, typically use only ONE authentication provider 
    for clarity and security. Multiple providers are mainly useful for:
	Environment-specific configurations (dev/test/prod)
	Migration scenarios
	Enterprise environments with multiple user sources
	The updated documentation now clearly shows when and why you'd use each provider 
	type, with practical examples and debugging guidance.
    -->
    
    <!-- SCENARIO 2: Multiple Providers (Fallback Chain) -->
    <!-- This configuration tries providers in sequence until one succeeds -->
    <!-- Authentication Manager -->
    <authentication-manager>
        <!-- In-Memory Authentication (for testing) -->
        <authentication-provider>
            <user-service>
                <user name="admin" 
                      password="{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW" 
                      authorities="ROLE_ADMIN,ROLE_USER" />
                <user name="user" 
                      password="{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW" 
                      authorities="ROLE_USER" />
            </user-service>
        </authentication-provider>

        <!-- Database Authentication Provider -->
        <authentication-provider user-service-ref="userDetailsService">
            <password-encoder ref="passwordEncoder" />
        </authentication-provider>

        <!-- Custom Authentication Provider -->
        <authentication-provider ref="customAuthenticationProvider" />
    </authentication-manager>

    <!-- Password Encoder Bean -->
    <beans:bean id="passwordEncoder" 
                class="org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder">
        <beans:constructor-arg value="12" />
    </beans:bean>

    <!-- Custom User Details Service -->
    <beans:bean id="userDetailsService" 
                class="com.example.security.CustomUserDetailsService" />

    <!-- Custom Authentication Provider -->
    <beans:bean id="customAuthenticationProvider"
                class="com.example.security.CustomAuthenticationProvider" />

    <!-- Custom Access Decision Manager -->
    <beans:bean id="accessDecisionManager" 
                class="org.springframework.security.access.vote.AffirmativeBased">
        <beans:constructor-arg>
            <beans:list>
                <beans:bean class="org.springframework.security.access.vote.RoleVoter" />
                <beans:bean class="org.springframework.security.access.vote.AuthenticatedVoter" />
                <beans:bean class="org.springframework.security.web.access.expression.WebExpressionVoter" />
            </beans:list>
        </beans:constructor-arg>
    </beans:bean>

    <!-- Security Event Listener -->
    <beans:bean id="securityEventListener"
                class="com.example.security.SecurityEventListener" />

</beans:beans>