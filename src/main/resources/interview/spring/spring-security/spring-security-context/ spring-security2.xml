<?xml version="1.0" encoding="UTF-8"?>
<beans:beans xmlns="http://www.springframework.org/schema/security"
             xmlns:beans="http://www.springframework.org/schema/beans"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xmlns:context="http://www.springframework.org/schema/context"
             xsi:schemaLocation="
                http://www.springframework.org/schema/beans
                http://www.springframework.org/schema/beans/spring-beans.xsd
                http://www.springframework.org/schema/context
                http://www.springframework.org/schema/context/spring-context.xsd
                http://www.springframework.org/schema/security
                http://www.springframework.org/schema/security/spring-security.xsd">

    <!-- Enable method level security -->
    <global-method-security pre-post-annotations="enabled" 
                           secured-annotations="enabled" 
                           jsr250-annotations="enabled" />

    <!-- HTTP Security Configuration -->
    <http auto-config="true" use-expressions="true">
        <!-- URL Access Rules -->
        <intercept-url pattern="/login" access="permitAll" />
        <intercept-url pattern="/logout" access="permitAll" />
        <intercept-url pattern="/public/**" access="permitAll" />
        <intercept-url pattern="/css/**" access="permitAll" />
        <intercept-url pattern="/js/**" access="permitAll" />
        <intercept-url pattern="/images/**" access="permitAll" />
        <intercept-url pattern="/admin/**" access="hasRole('ADMIN')" />
        <intercept-url pattern="/user/**" access="hasAnyRole('USER','ADMIN')" />
        <intercept-url pattern="/**" access="isAuthenticated()" />

        <!-- Form Login Configuration -->
        <form-login login-page="/login"
                   login-processing-url="/authenticate" 
                   default-target-url="/dashboard"
                   authentication-failure-url="/login?error=true"
                   username-parameter="username"
                   password-parameter="password" />

        <!-- Logout Configuration -->
        <logout logout-url="/logout"
               logout-success-url="/login?logout=true"
               delete-cookies="JSESSIONID"
               invalidate-session="true" />

        <!-- Session Management -->
        <session-management session-fixation-protection="changeSessionId">
            <concurrency-control max-sessions="1" 
                               error-if-maximum-exceeded="false"
                               expired-url="/login?expired=true" />
        </session-management>

        <!-- CSRF Protection -->
        <csrf disabled="false"/>

        <!-- Remember Me -->
        <remember-me key="uniqueAndSecret" 
                    token-validity-seconds="86400"
                    user-service-ref="userDetailsService" />

        <!-- Custom Access Denied Handler -->
        <access-denied-handler error-page="/access-denied" />

        <!-- Security Headers -->
        <headers>
            <cache-control />
            <content-type-options />
            <frame-options policy="DENY" />
            <xss-protection />
        </headers>
    </http>

    <!-- Authentication Manager with Multiple Providers -->
    <!-- 
    IMPORTANT: Spring Security tries authentication providers in the ORDER they are declared.
    The first provider that can handle the authentication type will be used.
    If it fails, Spring moves to the next provider.
    -->
    
    <!-- SCENARIO 1: Single Provider (Recommended for production) -->
    <!-- Use only ONE of the following authentication-manager blocks -->
    
    <!-- Option 1A: In-Memory Authentication (TESTING/DEV ONLY) -->
    <!--
    <authentication-manager alias="authManager1">
        <authentication-provider>
            <user-service>
                <user name="admin" 
                      password="{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW" 
                      authorities="ROLE_ADMIN,ROLE_USER" />
                <user name="user" 
                      password="{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW" 
                      authorities="ROLE_USER" />
            </user-service>
        </authentication-provider>
    </authentication-manager>
    -->

    <!-- Option 1B: Database Authentication (PRODUCTION) -->
    <!--
    <authentication-manager alias="authManager2">
        <authentication-provider user-service-ref="userDetailsService">
            <password-encoder ref="passwordEncoder" />
        </authentication-provider>
    </authentication-manager>
    -->

    <!-- Option 1C: Custom Authentication Provider (ENTERPRISE) -->
    <!--
    <authentication-manager alias="authManager3">
        <authentication-provider ref="customAuthenticationProvider" />
    </authentication-manager>
    -->

    <!-- SCENARIO 2: Multiple Providers (Fallback Chain) -->
    <!-- This configuration tries providers in sequence until one succeeds -->
    <authentication-manager>
        <!-- 1st: Try Custom Authentication (e.g., LDAP, OAuth, etc.) -->
        <authentication-provider ref="customAuthenticationProvider" />
        
        <!-- 2nd: Fallback to Database Authentication -->
        <authentication-provider user-service-ref="userDetailsService">
            <password-encoder ref="passwordEncoder" />
        </authentication-provider>
        
        <!-- 3rd: Final Fallback to In-Memory (NOT recommended for production) -->
        <!-- Only enable this for development/testing -->
        <!--
        <authentication-provider>
            <user-service>
                <user name="admin" 
                      password="{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW" 
                      authorities="ROLE_ADMIN,ROLE_USER" />
            </user-service>
        </authentication-provider>
        -->
    </authentication-manager>

    <!-- SCENARIO 3: Multiple Authentication Managers for Different URLs -->
    <!-- You can define multiple authentication managers and reference them -->
    <!--
    <authentication-manager id="adminAuthManager">
        <authentication-provider ref="ldapAuthenticationProvider" />
    </authentication-manager>
    
    <authentication-manager id="userAuthManager">
        <authentication-provider user-service-ref="userDetailsService">
            <password-encoder ref="passwordEncoder" />
        </authentication-provider>
    </authentication-manager>
    -->

    <!-- Then reference specific auth manager in http block -->
    <!--
    <http pattern="/admin/**" authentication-manager-ref="adminAuthManager">
        <intercept-url pattern="/admin/**" access="hasRole('ADMIN')" />
        <form-login />
    </http>
    
    <http pattern="/**" authentication-manager-ref="userAuthManager">
        <intercept-url pattern="/**" access="isAuthenticated()" />
        <form-login />
    </http>
    -->

    <!-- Password Encoder Bean -->
    <beans:bean id="passwordEncoder" 
                class="org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder">
        <beans:constructor-arg value="12" />
    </beans:bean>

    <!-- Custom User Details Service -->
    <beans:bean id="userDetailsService" 
                class="com.example.security.CustomUserDetailsService" />

    <!-- Custom Authentication Provider -->
    <beans:bean id="customAuthenticationProvider"
                class="com.example.security.CustomAuthenticationProvider" />

    <!-- Custom Access Decision Manager -->
    <beans:bean id="accessDecisionManager" 
                class="org.springframework.security.access.vote.AffirmativeBased">
        <beans:constructor-arg>
            <beans:list>
                <beans:bean class="org.springframework.security.access.vote.RoleVoter" />
                <beans:bean class="org.springframework.security.access.vote.AuthenticatedVoter" />
                <beans:bean class="org.springframework.security.web.access.expression.WebExpressionVoter" />
            </beans:list>
        </beans:constructor-arg>
    </beans:bean>

## Authentication Provider Usage Scenarios

### How Multiple Authentication Providers Work

When you have multiple `<authentication-provider>` elements in a single `<authentication-manager>`, Spring Security processes them in **sequence**:

1. **Order Matters**: Providers are tried in the order they appear in XML
2. **First Match Wins**: The first provider that can handle the authentication type attempts authentication
3. **Fallback Chain**: If authentication fails, Spring tries the next provider
4. **Stop on Success**: Once a provider successfully authenticates, the chain stops

### Real-World Usage Scenarios

#### Scenario 1: Development vs Production Environment
```xml
<!-- Development Profile -->
<beans profile="dev">
    <authentication-manager>
        <!-- Quick in-memory users for development -->
        <authentication-provider>
            <user-service>
                <user name="dev" password="{noop}dev" authorities="ROLE_ADMIN" />
                <user name="test" password="{noop}test" authorities="ROLE_USER" />
            </user-service>
        </authentication-provider>
    </authentication-manager>
</beans>

<!-- Production Profile -->
<beans profile="prod">
    <authentication-manager>
        <!-- Database authentication for production -->
        <authentication-provider user-service-ref="userDetailsService">
            <password-encoder ref="passwordEncoder" />
        </authentication-provider>
    </authentication-manager>
</beans>